// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4678.walle.commands;

import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc4678.walle.Robot;

/**
 *
 */
public class  RobotDrive extends Command {
	int MAX_DECCELERATION_SPEED = 10;
	double POWER_REDUCTION = Robot.driveMotorPowerReduction();
	double AUTO_SPEED_ADJUSTMENT_SPEED = 0.003;
	double ACCELERATION_LIMITING_ADJUSTMENT_SPEED = 0.005;
	double AUTO_SPEED_TARGET = 15;
	boolean checkedLast = false;
	double maxPowerForAcceleration = 0.3;
	double autoSpeedLeftPower = 0.1;
	double autoSpeedRightPower = 0.1;
	double autoSpeedLastLeftPosition = 0;
	double autoSpeedLastRightPosition = 0;
	double leftSpeedChange;
	double rightSpeedChange;
	double joystickX;
	double joystickY;
	double leftPower;
	double rightPower;
	double lastLeftPower = 0;
	double lastRightPower = 0;
	double averagePower = 0;
	double current0;
	double lastLeftDistance = 0;
	double lastRightDistance = 0;
	double acccelerationLimitLeftPower = 0;
	double accelerationLimitRightPower = 0;

	PowerDistributionPanel pdp = new PowerDistributionPanel();
    public RobotDrive() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	Robot.pickup.setLifterPower(0);
    	Robot.drivetrain.setIsDriving(true);
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	System.out.println(" Latch pressed is " + Robot.pickup.getDrivingOverTote() + " tote sensors are " + Robot.pickup.getToteSensor1() + "  " + Robot.pickup.getToteSensor2());
    	if (Robot.oi.getGamepad1().getPOV() == -1) {
    		//Make sure the dpad control powers start at 0.1, so it accelerates smoothly
        	autoSpeedRightPower = 0.1;
        	autoSpeedLeftPower = 0.1;
	    	//Get the joystick values
	    	joystickX = Robot.oi.getGamepad1().getX();
	        joystickY = -Robot.oi.getGamepad1().getY();
	        
	        //Determine the powers based on the joystick values, cubic for side to side
	        leftPower = joystickY + joystickX;
	        rightPower = joystickY - joystickX;
        
//--------------------------------------------------------------------------
//-------------------------------Steering Snap------------------------------
//--------------------------------------------------------------------------
        
	        SmartDashboard.putBoolean("Drivetrain Steering Snap", Robot.oi.getButton(Robot.oi.getGamepad1(), 8));
	        
	        if (Robot.oi.getButton(Robot.oi.getGamepad1(), 8)) {
	        	//Average the powers so you make the motors go the same speed
	        	averagePower = ((Math.abs(leftPower) + Math.abs(rightPower)) / 2);
	        	System.out.println("------- average power = " + averagePower);
	        	//Flip the powers if necessary
	        	if (leftPower > 0) {
	        		leftPower = averagePower;
	        	} else {
	        		leftPower = -averagePower;
	        	}
	        	
	        	//Flip the powers if necessary
	        	if (rightPower > 0) {
	        		rightPower = averagePower;
	        	} else {
	        		rightPower = -averagePower;
	        	}
	        }

        	
//--------------------------------------------------------------------------
//------------------------------Power Reduction-----------------------------
//--------------------------------------------------------------------------
	        
        	leftPower *= Robot.drivetrain.getPowerReduction();
        	rightPower*= Robot.drivetrain.getPowerReduction();

//--------------------------------------------------------------------------
//---------------------------------Set Powers-------------------------------
//--------------------------------------------------------------------------

	        Robot.drivetrain.setMotor("left", -leftPower);
	        Robot.drivetrain.setMotor("right", -rightPower);
	        
	        lastLeftPower = leftPower;
	        lastRightPower = rightPower;
	        
	        //SmartDashboard.putNumber("Right Motor Power", rightPower);
	        //SmartDashboard.putNumber("Left Motor Power", leftPower);
	        SmartDashboard.putNumber("Right Encoder", Robot.drivetrain.getRightEncoder());
	        SmartDashboard.putNumber("Left Encoder", Robot.drivetrain.getLeftEncoder());
	        SmartDashboard.putNumber("Lifter Height", Robot.pickup.getLifterHeight());
	        SmartDashboard.putNumber("Arm Position", Robot.arm.getArmPosition());
	        SmartDashboard.putNumber("Squeeze Position", Robot.squeeze.getOpenPosition());
	        SmartDashboard.putNumber("Claw Position", Robot.claw.getClawPosition());
	        SmartDashboard.putNumber("Index Position", Robot.indexWheels.getIndexPosition());
	        SmartDashboard.putNumber("Back Distance", Robot.drivetrain.getBackDistanceSensor());
	        SmartDashboard.putNumber("Power Reduction", Robot.drivetrain.getPowerReduction());
	        SmartDashboard.putBoolean("Tote sensor 1: ", Robot.pickup.getToteSensor1());
	        SmartDashboard.putNumber("gyro", Robot.drivetrain.getGyro());
	        SmartDashboard.putNumber("garbagePosition", Robot.trashMagnet.getGarbagePosition());

    	} else {//Use the dpad if it is pressed
    		
    		if (!checkedLast) {//Only check every other time, to get a more accurate encoder reading
    			rightSpeedChange = Math.abs(Math.abs(Robot.drivetrain.getRightEncoder()) - Math.abs(autoSpeedLastRightPosition));
        		leftSpeedChange = Math.abs(Math.abs(Robot.drivetrain.getLeftEncoder()) - Math.abs(autoSpeedLastLeftPosition));
        		
	    		if (rightSpeedChange > AUTO_SPEED_TARGET + 1) {
	    			autoSpeedRightPower -= AUTO_SPEED_ADJUSTMENT_SPEED;
	    		} else if (rightSpeedChange < AUTO_SPEED_TARGET - 1) {
	    			autoSpeedRightPower += AUTO_SPEED_ADJUSTMENT_SPEED;
	    		}
	    		
	    		if (leftSpeedChange > AUTO_SPEED_TARGET + 1) {
	    			autoSpeedLeftPower -= AUTO_SPEED_ADJUSTMENT_SPEED;
	    		} else if (leftSpeedChange < AUTO_SPEED_TARGET - 1) {
	    			autoSpeedLeftPower += AUTO_SPEED_ADJUSTMENT_SPEED;
	    		}
	    		
	    		if (autoSpeedLeftPower > 0.4) {
	    			autoSpeedLeftPower = 0.4;
	    		}
	    		
	    		if (autoSpeedRightPower > 0.4) {
	    			autoSpeedRightPower = 0.4;
	    		}
	    		
	    		autoSpeedLastRightPosition = Robot.drivetrain.getRightEncoder();
	    		autoSpeedLastLeftPosition = Robot.drivetrain.getLeftEncoder();
    		}
    		
    		checkedLast = !checkedLast;
    		
    		leftPower = autoSpeedLeftPower;
    		rightPower = autoSpeedRightPower;
    		
    		switch (Robot.oi.getGamepad1().getPOV()) {
    		
    		case 0:
    		break;
    		case 90:
    			rightPower *= -1;
    		break;
    		case 180:
    			rightPower *= -1;
    			leftPower *= -1;
    		break;
    		case 270:
    			leftPower *= -1;
    		break;
    		}
    		
    		
    		Robot.logger.debug("RobotDrive", "Using DPad to control, current speed is " + rightSpeedChange + ", " + leftSpeedChange);
    		Robot.logger.debug("RobotDrive", "Using DPad, setting powers to " + rightPower + ", " + leftPower);
    		
    		Robot.drivetrain.setMotor("left", -leftPower);
    		Robot.drivetrain.setMotor("right", -rightPower);
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
