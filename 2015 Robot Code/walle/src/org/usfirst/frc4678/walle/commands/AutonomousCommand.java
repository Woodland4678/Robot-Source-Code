// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.


package org.usfirst.frc4678.walle.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc4678.walle.Robot;

/**
 *
 */
public class  AutonomousCommand extends Command {
	boolean liftUpLess = false;
	boolean finished = false;
	boolean pickingUpTote = false;
	int autoState = 0;
	int pickupState = 0; // was 0
	int armState = 0;
	int armCount = 0;
	int indexState = 0;
	int count = 0;
	int autoMode = Robot.autoMode();
	int trashMagnetState = 0;
    public AutonomousCommand() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	Robot.drivetrain.resetGyro();
    	autoState = 0;
    	autoMode = Robot.autoMode();
    	count = 0;
    	pickupState = 5; //was 5
    	armState = 5;
    	Robot.drivetrain.setAuton(true);
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	System.out.println("Auto state is " + autoState);
//--------------------------------------------------------------------------
//------------------------------move 2 meters-------------------------------
//--------------------------------------------------------------------------
    	
    	if (autoMode == 0) {
    		switch(autoState) {
    		case 0://Get the pickup ready for the match and move forwards
    			pickupState = 5;
	    		if (Robot.drivetrain.goToDistance(180, 180, .7, 30, 20, 0.5, 0.2)) {
	    			autoState ++;
	    		}
	    	break;
    		}
    	

//--------------------------------------------------------------------------
//----------------------------1 tote 2 containers---------------------------
//--------------------------------------------------------------------------
    	
    	} else if (autoMode == 1) {
	    	switch(autoState) {
	    	case 0://Pick up the first bin(s) and tote (after this, the pickup will automatically check for totes and pick them up)
	    		armCount = 0;
	    		pickupState = 3;
	    		indexState = 0;
	    		liftUpLess = false;
	    		armState = 0;
	    		count = 0;
	    		autoState ++;
	    		Robot.indexWheels.setIndexMotor(1);
	    		pickupState = 2;
	    	break;
	    	case 1://Wait for the Robot to pick up the bin and tote
	    		if (pickupState == 3 || pickupState == 0) {
		    		count ++;
		    		if (count > 60) {
		    			autoState ++;
		    		}
	    		}
	    	break;
	    	case 2://Turn to face the auto zone
	    		if (Robot.drivetrain.turn(90, 0.7)) {
	    			autoState ++;
	    			count = 0;
	    		}
	    	break;
	    	case 3://Move into the auto zone
	    		if (Robot.drivetrain.goToDistance(200, 200, .85, 20, 60, 0.5, 0.2)) {
	    			autoState ++;
	    			count = 0;
	    		}
	    	break;
	    	case 4://Turn to be parallel to the scoring platform, and start dropping the totes
	    		if (Robot.drivetrain.turn(-90, 0.7)) {
	    			autoState ++;
	    			pickupState = 6;
	    			count = 0;
	    		}
	    	break;
	    	case 10://Wait for the totes to be dropped
	    		count ++;
	    		if (count > 80) {
	    			autoState ++;
	    		}
	    	break;
	    	case 11://Go forwards
	    		if (Robot.drivetrain.goToDistance(120, 120, .6, 10, 10, 0.5, 0.2)) {
	    			autoState ++;
	    		}
	    	case 12://Get the pickup ready for the match
	    		pickupState = 5;
	    	break;
	    	}
	    	
//--------------------------------------------------------------------------
//--------------------------3 totes and containers--------------------------
//--------------------------------------------------------------------------
	    	
	    	
	    	//April 22 Changes:
	    	//Increaced wait for second tote
	    	//made pickup state only go to 0 when auto state 3 ends
	    	//Last tote pickup decellerates and accelerates for 30 cm not 10 cm, and decellerates to 0.2 instead of 0.1
    	} else if (autoMode == 3) {
    		SmartDashboard.putNumber("gyro", Robot.drivetrain.getGyro());
    		switch(autoState) {
	    	case 0://Pick up the first bin(s) and tote
	    		armCount = 0;
	    		pickupState = 8;
	    		indexState = 0;
	    		liftUpLess = false;
	    		armState = 1;
	    		count = 0;
	    		trashMagnetState = 0;
	    		autoState ++;
	    		Robot.indexWheels.setIndexMotor(1);
	    		
	    	break;
	    	case 1://Wait for the Robot to pick up the bin and tote
	    		count ++;
	    		if (count > 10) {
	    			trashMagnetState = 1;
	    		}
	    		if (count > 60 || Robot.arm.getArmPosition() > 4) {
	    			autoState ++;
	    			pickupState = 5; // 19-Apr This will go to lifter fully up
	    			// Once the fully up position is reached, the pickupState is
	    			// set to 0 in the pickupState code.  Recommend staying in 
	    			// pickupState = 3 till autoState gets to at least 4
	    		}
	    	break;
	    	case 2://Move forwards to the next bin.  This puts the robot almost in position
	    		// to pick up the second tote but we're usually just a wee bit short
	    		// of the pickup position.
	    		if (Robot.drivetrain.goToDistance(215, 215, .5, 30, 40, 0.5, 0.15)) {
	    			autoState ++;
	    			armState = 0;
	    			count = 0;
	    			pickupState = 0;
	    		}
	    	break;
	    	case 3://Wait for the robot to pick up the container
	    		count ++;
	    		if (armState == 2) {//This ensures the arm goes to rest, and not to drop the bin
	    			armState = 5;
	    		}
	    		
	    		if (Robot.arm.getArmPosition() > 3 && armState == 5) { //was 70 //count > 80 && 
	    			//pickupState = 0;
	    			autoState ++;
	    		}
	    	break;
	    	case 4://Move forwards to the last tote //was 220 not 175
	    		if (Robot.drivetrain.goToDistance(175, 175, .4, 10, 30, 0.5, 0.25)) {
	    			autoState ++;
	    			armState = 5;
	    			count = 0;
	    		}
	    	break;
	    	case 5://Wait for the robot to stop pick up the second tote
	    		count ++;
	    		if (count > 2) {
	    			autoState ++;
	    			 // 19-Apr Lifter will go fully up in State 5
	    			// This might not let the lifter go low enough. If sensors
	    			// are slightly delayed in detecting a tote, it is possible
	    			// That we will set the pickupState to 5 before it reaches
	    			// the lifterPickupTarget() because this is purely based on
	    			// a timer and is ignoring the sensors.  Recommend a somewhat
	    			// longer timer but change to (count > 50)||(lifterPickupTarget has been reached)
	    			// Do we run into time issues if this takes a bit longer?  Is there
	    			// anywhere we can save ourselves a little bit of time in auto?
	    			// Do we need to? Most matches, it looks like we are done in 13 seconds.
	    		}
	    		if (Robot.pickup.getLifterHeight() < Robot.lifterPickupTarget() + 0.05) {
	    			pickupState = 5;
	    		}
	    		Robot.drivetrain.resetGyro();
	    	break;
	    	case 6://Turn to face the platform.  19-Apr - The last tote is just
	    		// going to be dragged along by the wheels.  There is no
	    		// attempt to try to pick it up.  The 2 totes we already
	    		// have need to be kept lifted as we go over the platform
	    		if (Robot.pickup.getLifterHeight() < Robot.lifterPickupTarget() + 0.05) {
	    			pickupState = 5;
	    		}
	    		if (Robot.drivetrain.gyroTurn(-100)) {
	    			autoState ++;
	    			count = 0;
	    		}
	    	break;
	    	case 7:
	    		count ++;
	    		if (count > 10) {
	    			autoState ++;
	    		}
	    	break;
	    	case 8://Go over the platform //was about 200
	    		pickupState = 5;
	    		if (Robot.drivetrain.goToDistance(300, 300, .50, 40, 0, .4, 0)) {
	    			autoState++;
	    			count = 0;
	    			Robot.drivetrain.resetGyro();
	    		}
	    	break;
	    	case 9://Turn 90 degrees
	    		//Robot.drivetrain.goToDistance(220, 110, .45, 30, 0, 0, 0
	    		if (count > 32) {
	    			trashMagnetState = 2;
	    		}
	    		count++;
	    		if (Robot.drivetrain.gyroTurn(-85)) { //was 78
	    			Robot.frontforks.liftForks();
	    			trashMagnetState = 2;
	    			autoState++;
	    			count = 0;
	    			Robot.indexWheels.setIndexMotor(-1);
	    			Robot.indexWheels.setIndexWheels(Robot.indexOpenPosition());
	    			indexState = 2;
	    		}
	    	break;
	    	case 10: //stop then drop.  19-Apr The drop will be initiated right away
	    		// But the forward movement will be delayed by 0.5 seconds, allowing
	    		// the lifter to be pretty much down by the time the forward 
	    		// movement takes place.  This also allows the wheels to be moved
	    		// fully open before we start moving forward.
	    		count++;
	    		if(count > 35) {
	    			autoState++;
	    		}
	    		pickupState = 6;
	    		trashMagnetState = 2;
	    		
	    	break;
	    	case 11://Turn the last 45 degrees while dropping the totes (increased right from 165 to 185)
	    		trashMagnetState = 3;
	    		if (Robot.drivetrain.goToDistance(100, 100, .6, 0, 0, 0, 0)) {
	    			autoState ++;
	    			pickupState = 6;
	    			count = 0;
	    		}
	    	break;
	    	/*case 12://Go back a bit to make sure the totes are clear
	    		if (Robot.drivetrain.goToDistance(50, 50, .85, 0, 0, 0, 0)) {
	    			autoState ++;
	    			count = 0;
	    		}
	    	break;*/
	    	case 12: 
	    		
	    		count++;
	    		if (count > 25) {
	    			Robot.drivetrain.setMotor("both", 0);
	    			//autoState++;
	    		}
	    		
	    		
	    	}
	    	
    	}
    	
//--------------------------------------------------------------------------
//-------------------------------Pickup setter------------------------------
//--------------------------------------------------------------------------
    	
    	//This code automatically sets the pickup height based on the pickupState
    	//States 0-3 automatically pick up a tote when it is under the robot, and
    	//State 4 makes the pickup ready to pick up
    	//State 5 lifts the pickup to the max height
    	//State 6 lowers the pickup to the minimum height
    	//State 7 lowers the pickup to the minimum height without scoring the totes
    	System.out.println("tote sensor is " + Robot.pickup.getToteSensor1() + " picku pstate is " + pickupState);
    	switch(pickupState) {
    	
    	case 0://Wait for a tote to be sensed
    		// 19-Apr If we get to State 0 and something gives us a glitch input on the
    		// spring-loaded tote arm, lifter could easily go back down
    		// Best to ensure we don't go to state 0 till we are sure we are
    		// over the tote (autoState >= 4)
    		if (Robot.pickup.getDrivingOverTote()) {
    			pickupState ++;
    		}
    	break;
    	case 1://Wait for the tote to pass under the robot
    		if (!Robot.pickup.getDrivingOverTote() && Robot.pickup.getToteSensor1()) {
    			pickupState ++;
    		}
    	break;
    	case 2://Drop the pickup down
    		if (Robot.pickup.lift(Robot.lifterPickupTarget())) {
    			pickupState ++;
    			pickupState = 7;
    		}
    	break;
    	case 3://Lift the pickup up, and then go back to state 0
    		// 19-Apr - add a change to ensure we can only go to state 0 after autoState >= 4
    		// That way we can be sure we are over the next tote before lifter is allowed to
    		// go back down due to some sort of sensor glitch
    		if (Robot.pickup.lift(Robot.lifterUpperTarget())) {
    			pickupState = 0;
    		}
    	break;
    	case 4://Go to the pickup target
    		Robot.pickup.lift(Robot.lifterPickupTarget());
    	break;
    	case 5://Go to the pickup max
    		Robot.pickup.lift(Robot.lifterUpperTarget());
    	break;
    	case 6://Go to the pickup min
    		Robot.pickup.lift(Robot.lifterScoreTarget());
    	break;
    	case 7://Go as low as the pickup can go without scoring
    		Robot.pickup.lift(Robot.lifterSixToteTarget());
    	break;
    	case 8:
    		if (Robot.pickup.lift(Robot.lifterPickupTarget())) {
    			pickupState = 7;
    		}
    	break;
    	case 9://Go to a bit below the pickup max
    		Robot.pickup.lift(Robot.lifterUpperTarget() - 1);
    	break;
    	}
    	
//--------------------------------------------------------------------------
//-------------------------------Arm setter------------------------------
//--------------------------------------------------------------------------
    	System.out.println("Arm state " + armState);
    	//When the pickup state is 0, it goes through the pickup loop
    	switch(armState) {
    	case 0://go to pickup position and open the claw
    		Robot.squeeze.openArm(Robot.armOpenPosition());
    		Robot.arm.setCurrentArmPosition(Robot.armPickupPosition() + 0.2);
    		if (Math.abs(Robot.arm.getArmPosition() - Robot.armPickupPosition()) < 0.75) {
    			armCount = 0;
    			armState ++;
    		}
    	break;
    	case 1://Close the claw
    		armCount ++;
    		Robot.squeeze.openArm(Robot.armClosePosition());
    		if (armCount > 10) {//Wait for the claw to close
    			Robot.claw.setClawTargetDegrees(15);
    			if (armCount > 20) {
    				armState ++;
    			}
    		}
    	break;
    	case 2://Go to set bin position
    		if (Robot.armZeroDegreesValue() < Robot.arm.getArmPosition() && Robot.claw.getClawTargetDegrees() > 0) {//Gradually reduce the bin angle
    			Robot.claw.setClawTargetDegrees(Robot.claw.getClawTargetDegrees() - 1);
    		}
    		
    		Robot.arm.setCurrentArmPosition(Robot.armSetBinPosition());
    		Robot.squeeze.openArm(Robot.armClosePosition());
    		if (Math.abs(Robot.armSetBinPosition() - Robot.arm.getArmPosition())  < 0.05) { //was 0.05
    			armCount = 0;
    			armState ++;
    		}
    	break;
    	case 3://Open the claw
    		armCount ++;
    		//if (armCount > 10) { //was 15
				Robot.squeeze.openArm(Robot.armOpenPosition());
				if (armCount > 40) {
					armState ++;
				}
    		//}
    	break;
    	case 4://Go to pickup position
    		Robot.squeeze.openArm(Robot.armOpenPosition());
    		Robot.arm.setCurrentArmPosition(Robot.armPickupPosition());
    	break;
    	case 5://Go to rest position
    		Robot.claw.setClawTargetDegrees(0);
    		Robot.squeeze.openArm(Robot.armClosePosition());
    		Robot.arm.setCurrentArmPosition(Robot.armRestPosition() - 0.5);
    	break;
    	case 6://Go to the bin setting position
    		Robot.arm.setCurrentArmPosition(Robot.armSetBinPosition());
    	break;
    	}
   //Index wheel setter
    	switch (indexState) {
    	case 0:
    		Robot.indexWheels.setIndexWheels(Robot.indexClosePosition());
    		break;
    	case 1:
    		Robot.indexWheels.setIndexWheels(Robot.indexCenterPosition());
    		break;
    	case 2:
    		Robot.indexWheels.setIndexWheels(Robot.indexOpenPosition());
    		break;
    	}
    //Trash Magnet setter
    	switch(trashMagnetState) {
    	case 0:
    		Robot.trashMagnet.setLatchServo(Robot.latchOpenPosition());
    		break;
    	case 1:
    		Robot.trashMagnet.setGarbageWinch(Robot.garbageMagnetlowerTarget());
    		break;
    	case 2:
    		Robot.trashMagnet.setLatchServo(Robot.latchClosedPosition());
    		break;
    	case 3:
    		Robot.trashMagnet.setGarbageWinch(Robot.garbageMagnetUpperTarget());
    		break;
    	}

    	Robot.logger.debug("Autonomous", "Auto state at " + autoState);
    	
    	Robot.logger.debug("Autonomous", "Pickup state at " + pickupState + " Latch pressed is " + Robot.pickup.getDrivingOverTote());
    	
    	Robot.logger.debug("Autonomous", "Arm state at " + armState + " Arm target is  " + Robot.arm.getArmTarget());
    	
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return finished;
    }

    // Called once after isFinished returns true
    protected void end() {
    	autoState = 0;
    	Robot.pickup.setLifterPower(0);
    	Robot.indexWheels.stopOpenMotor();
    	Robot.drivetrain.setMotor("both", 0);
    	Robot.trashMagnet.stopTrashMagnetMotor();
    	Robot.drivetrain.setAuton(false);
    	Robot.trashMagnet.setGarbageWinch(Robot.garbageMagnetUpperTarget());
    	Robot.frontforks.liftForks();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	end();
    }
}
