// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.


package org.usfirst.frc4678.walle.subsystems;

import org.usfirst.frc4678.walle.Robot;
import org.usfirst.frc4678.walle.RobotMap;
import org.usfirst.frc4678.walle.commands.*;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Drivetrain extends Subsystem {
	int ENCODER_DIFFERENCE_PER_TURN = Robot.encoderChangePerTurn();
	int LIGHT_SENSOR_MARGIN = Robot.lightSensorMargin();
	double GO_TO_BOX_TURN_SPEED = Robot.goToBoxTurnSpeed();
	int TARGET_LIGHT_SENSOR_VALUE = Robot.targetLightSensorValue();
	double AUTO_TURN_MARGIN = .05;//This is a percentage
	double AUTO_TURN_REDUCTION_SPEED = Robot.autoTurnReductionSpeed();
	double AUTO_TURN_REDUCTION_DISTANCE = 0.7;//Starts reducing the speed when it is x percent of the way to the target distance
	long goalTime;
	int timedDriveState = 0;
	int goToDistanceState = 0;
	int turnState = 0;
	int startingLeftDistance;
	int startingRightDistance;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController leftMotor = RobotMap.drivetrainLeftMotor;
    SpeedController rightMotor = RobotMap.drivetrainRightMotor;
    AnalogInput leftDistSensor = RobotMap.drivetrainLeftDistSensor;
    AnalogInput rightDistSensor = RobotMap.drivetrainRightDistSensor;
    Encoder leftEncoder = RobotMap.drivetrainLeftEncoder;
    Encoder rightEncoder = RobotMap.drivetrainRightEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new RobotDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public void setMotor(String motor, double power) {
    	if (motor.equals("left") || motor.equals("Left")) {
    		//This is negative because the left gearbox is facing in the opposite direction
    		leftMotor.set(-power);
    	} else if (motor.equals("right") || motor.equals("Right")) {
    		rightMotor.set(power);
    	} else if (motor.equals("both") || motor.equals("Both")) {
    		//This is negative because the left gearbox is facing in the opposite direction
    		leftMotor.set(-power);
    		rightMotor.set(power);
    	}
    }
    
  //To use this method, you keep calling it until it returns true
    public boolean timedDrive(double leftPower, double rightPower, int milliseconds) {
    	Robot.logger.debug("Drivetrain", "Timed drive " + (goalTime - milliseconds) + " milliseconds from target");
    	//Goal time is -1 if it has not been set
    	if (timedDriveState == 0) {
    		goalTime = System.currentTimeMillis() + milliseconds;
    		timedDriveState ++;
    	}
    	
    	if (goalTime > System.currentTimeMillis()) {
    		Robot.drivetrain.setMotor("left", leftPower);
    		Robot.drivetrain.setMotor("right", rightPower);
    		
    	} else {
    		Robot.drivetrain.setMotor("both", 0);
    		timedDriveState = 0;
    		Robot.logger.info("Drivetrain", "Timed drive completed");
    		return true;
    	}
    	
    	return false;
    }
    
    //To use this method, you keep calling it until it returns true
    public boolean goToDistance(double targetLeft, double targetRight, double power) {
    	//If this method is being called for the first time since it last finished, you want to record the initial encoder values
    	if (goToDistanceState == 0) {
    		startingLeftDistance = getLeftEncoder();
    		startingRightDistance = getRightEncoder();
    		Robot.logger.info("Drivetrain", "goToDistance starting encoder values are " + startingRightDistance + ", " + startingLeftDistance);
    	}
    	
    	//Get how far the left and right sides have traveled
    	double currentLeft = getLeftEncoder() - startingLeftDistance;
    	double currentRight = getRightEncoder() - startingRightDistance;
    	
    	//Find the percentage the left and right are to their target
    	double leftPercentThere = currentLeft / targetLeft;
    	double rightPercentThere = currentRight / targetRight;
    	//Robot.logger.debug("Drivetrain", "gpToDistance Percentages At " + rightPercentThere + ", " + leftPercentThere);
    	
    	//Initially set the powers to their default values
        double leftPower = power;
        double rightPower = power;
        
        //Only start adjusting the powers once the motors have gone 2 percent of the target distance, to avoid calculation errors
        if ((currentRight >= (targetRight * 0.02)) && (currentLeft >= (targetLeft * 0.02))) {
        	
        	//This finds the difference between how far the left and right sides have gone
            double powerOffset = 20 * Math.abs(rightPercentThere - leftPercentThere);
            Robot.logger.debug("Drivetrain", "goToDistance Power Offset At " + powerOffset);
            
            //If the right is closer than the left, increase the left power and decrease the right power
            if (rightPercentThere > (leftPercentThere + 0.001)) {
                leftPower *= 1 - powerOffset;
                rightPower *= 1 + powerOffset;
            }
            
            //If the left is closer than the right, increase the right power, and decrease the left power
            if ((rightPercentThere + 0.001) < leftPercentThere) {
                leftPower *= 1 + powerOffset;
                rightPower *= 1 - powerOffset;
            }
        }
        Robot.logger.debug("Drivetrain", "goToDistance percentages at " + rightPercentThere + ", " + leftPercentThere);
        
        //We use the absolute values for setting the powers, so we have to flip the powers based on what direction the robot is going
        if (targetRight > startingRightDistance) {
            setMotor("left", leftPower);
            setMotor("right", rightPower);
            Robot.logger.debug("Drivetrain", "goToDistance setting powers to " + rightPower + ", " + leftPower);
        } else {
        	setMotor("left", -leftPower);
            setMotor("right", -rightPower);
            Robot.logger.debug("Drivetrain", "goToDistance setting powers to " + (-rightPower) + ", " + (-leftPower));
        }
        
        //If the left and the right both have gone far enough stop the motors, and reset the goToDistanceState so that the next time
        //the method is called, it will record the starting encoder values again
        if (rightPercentThere >= 100 && leftPercentThere >= 100) {
        	setMotor("both", 0);
        	goToDistanceState = 0;
        	Robot.logger.info("Drivetrain", "goToDistance at target");
        	return true;
        }
        
        return false;
    }
    
    //This function has to be constantly called until it returns true
    public boolean goToBox(double power) {
    	double leftPower = power;
    	double rightPower = power;
    	
    	Robot.logger.debug("Drivetrain", "goToBox light sensors at " + getRightLightSensor() + ", " + getLeftLightSensor());
    	//If the left is sensing and the right is not, turn left
    	if (getLeftLightSensor() > getRightLightSensor() + LIGHT_SENSOR_MARGIN) {
    		leftPower -= GO_TO_BOX_TURN_SPEED;
    		rightPower += GO_TO_BOX_TURN_SPEED;
    		
    	//If the right is sensing, and the left is not, turn right
    	} else if (getRightLightSensor() > getLeftLightSensor() + LIGHT_SENSOR_MARGIN) {
    		leftPower += GO_TO_BOX_TURN_SPEED;
    		rightPower -= GO_TO_BOX_TURN_SPEED;
    	}
    	
    	//Return true if the sensors are close enough to the target
    	if (getRightLightSensor() > TARGET_LIGHT_SENSOR_VALUE || getLeftLightSensor() > TARGET_LIGHT_SENSOR_VALUE) {
    		setMotor("both", 0);
    		Robot.logger.info("Drivetrain", "goToBox at box");
    		return true;
    	}
    	
    	Robot.logger.debug("Drivetrain", "goToDistance setting powers to " + rightPower + ", " + leftPower);
    	setMotor("left", leftPower);
    	setMotor("right", rightPower);
    	return false;
    }
    
    //This function has to be constantly called until it returns true
    public boolean turn(int degrees, double power) {
    	double leftPower = power;
    	double rightPower = power;
    	//Set the starting values if this is the first time the function is being called
    	if (turnState == 0) {
    		startingLeftDistance = getLeftEncoder();
    		startingRightDistance = getRightEncoder();
    		turnState ++;
    	}
    	//Determine the difference there should be between the encoders when the robot has completed the turn
    	int goalDifference = (ENCODER_DIFFERENCE_PER_TURN * degrees);
    	goalDifference = goalDifference / 360;
    	
    	if (goalDifference == 0) {
    		goalDifference = 1;
    		Robot.logger.warning("Drivetrain", "turn goalDifference is 0");
    	}
    	
    	int currentDifference = Math.abs((getLeftEncoder() - startingLeftDistance) - (getRightEncoder() - startingRightDistance));
    	int percentThere = (currentDifference / goalDifference);
    	Robot.logger.debug("Drivetrain", "turn " + percentThere + "% through the turn");
    	
    	//If the robot has overshot, do not start increasing the speed
    	if (percentThere > 1) {
    		percentThere = 1 - (percentThere - 1);
    	}
    	
    	//Start reducing speed if the robot has passed the reduction distance
    	if (percentThere > AUTO_TURN_REDUCTION_DISTANCE) {
    		leftPower *= (1 - ((percentThere - AUTO_TURN_REDUCTION_DISTANCE) * AUTO_TURN_REDUCTION_SPEED));
    		rightPower *= (1 - ((percentThere - AUTO_TURN_REDUCTION_DISTANCE) * AUTO_TURN_REDUCTION_SPEED));
    		Robot.logger.debug("Drivetrain", "turn reducing power because it is close to the target");
    	}
    	
    	//If the robot is within the margin, stop the motors and return true
    	if (Math.abs(percentThere - 1) < AUTO_TURN_MARGIN) {
    		setMotor("both", 0);
    		turnState = 0;
    		Robot.logger.info("Drivetrain", "turn completed turn");
    		return true;
    	}
    	
    	//Invert the powers if necessary
    	if (degrees > 0) {
    		if (currentDifference < goalDifference) {
    			//If the robot is turning right and has not hit the target
    			leftPower *= -1;
    		} else {
    			//If the robot is turning right and has gone too far
    			rightPower *= -1;
    		}
    	} else {
    		if (currentDifference > goalDifference) {
    			//If the robot is turning left and has not hit the target
    			rightPower *= -1;
    		} else {
    			//If the robot is turning left and has gone too far
    			leftPower *= -1;
    		}
    	}
    	
    	setMotor("left", leftPower);
    	setMotor("right", rightPower);
    	Robot.logger.debug("Drivetrain", "turn setting powers to " + rightPower + ", " + leftPower);
    	
    	return false;
    }
    
    public int getLeftLightSensor() {return leftDistSensor.getValue();}
    
    public int getRightLightSensor() {return rightDistSensor.getValue();}
    
    public int getLeftEncoder() {return -leftEncoder.get();}
    
    public int getRightEncoder() {return rightEncoder.get();}
    
    
}

