// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.


package org.usfirst.frc4678.walle.subsystems;

import org.usfirst.frc4678.walle.Robot;
import org.usfirst.frc4678.walle.RobotMap;
import org.usfirst.frc4678.walle.commands.*;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Drivetrain extends Subsystem {
	double LEFT_DEFAULT_GO_TO_DISTANCE_POWER;
	double RIGHT_DEFAULT_GO_TO_DISTANCE_POWER;
	long goalTime;
	int timedDriveState = 0;
	int goToDistanceState = 0;
	int startingLeftDistance;
	int startingRightDistance;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController leftMotor = RobotMap.drivetrainLeftMotor;
    SpeedController rightMotor = RobotMap.drivetrainRightMotor;
    AnalogInput leftDistSensor = RobotMap.drivetrainLeftDistSensor;
    AnalogInput rightDistSensor = RobotMap.drivetrainRightDistSensor;
    Encoder leftEncoder = RobotMap.drivetrainLeftEncoder;
    Encoder rightEncoder = RobotMap.drivetrainRightEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new RobotDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public void setMotor(String motor, double power) {
    	Robot.logger.debug("Drivetrain", "Setting " + motor + " to " + power);
    	if (motor.equals("left") || motor.equals("Left")) {
    		leftMotor.set(power);
    	} else if (motor.equals("right") || motor.equals("Right")) {
    		rightMotor.set(power);
    	} else if (motor.equals("both") || motor.equals("Both")) {
    		leftMotor.set(power);
    		rightMotor.set(power);
    	}
    }
    
  //To use this method, you keep calling it until it returns true
    public boolean timedDrive(double leftPower, double rightPower, int milliseconds) {
    	//Goal time is -1 if it has not been set
    	if (timedDriveState == 0) {
    		goalTime = System.currentTimeMillis() + milliseconds;
    		timedDriveState ++;
    	}
    	
    	if (goalTime > System.currentTimeMillis()) {
    		Robot.drivetrain.setMotor("left", leftPower);
    		Robot.drivetrain.setMotor("right", rightPower);
    		
    	} else {
    		Robot.drivetrain.setMotor("both", 0);
    		timedDriveState = 0;
    		return true;
    	}
    	
    	return false;
    }
    
    //To use this method, you keep calling it until it returns true
    public boolean goToDistance(double targetLeft, double targetRight) {
    	//If this method is being called for the first time since it last finished, you want to record the initial encoder values
    	if (goToDistanceState == 0) {
    		startingLeftDistance = getLeftEncoder();
    		startingRightDistance = getRightEncoder();
    	}
    	
    	//Get how far the left and right sides have traveled
    	double currentLeft = (getLeftEncoder() - startingLeftDistance);
    	double currentRight = getRightEncoder() - startingRightDistance;
    	
    	//Find the percentage the left and right are to their target
    	double leftPercentThere = currentLeft / targetLeft;
    	double rightPercentThere = currentRight / targetRight;
    	Robot.logger.debug("Drivetrain", "Percentages At " + rightPercentThere + ", " + leftPercentThere);
    	
    	//Initially set the powers to their default values
        double leftPower = LEFT_DEFAULT_GO_TO_DISTANCE_POWER;
        double rightPower = RIGHT_DEFAULT_GO_TO_DISTANCE_POWER;
        
        //Only start adjusting the powers once the motors have gone 2 percent of the target distance, to avoid calculation errors
        if ((currentRight >= (targetRight * 0.02)) && (currentLeft >= (targetLeft * 0.02))) {
        	
        	//This finds the difference between how far the left and right sides have gone
            double powerOffset = 20 * Math.abs(rightPercentThere - leftPercentThere);
            
            //If the right is closer than the left, increase the left power and decrease the right power
            if (rightPercentThere > (leftPercentThere + 0.001)) {
                leftPower *= 1 - powerOffset;
                rightPower *= 1 + powerOffset;
            }
            
            //If the left is closer than the right, increase the right power, and decrease the left power
            if ((rightPercentThere + 0.001) < leftPercentThere) {
                leftPower *= 1 + powerOffset;
                rightPower *= 1 - powerOffset;
            }
        }
        
        //We use the absolute values for setting the powers, so we have to flip the powers based on what direction the robot is going
        if (targetRight > startingRightDistance) {
            setMotor("left", -leftPower);
            setMotor("right", rightPower);
        } else {
        	setMotor("left", leftPower);
            setMotor("right", -rightPower);
        }
        
        //If the left and the right both have gone far enough stop the motors, and reset the goToDistanceState so that the next time
        //the method is called, it will record the starting encoder values again
        if (rightPercentThere >= 100 && leftPercentThere >= 100) {
        	setMotor("both", 0);
        	goToDistanceState = 0;
        	return true;
        }
        
        return false;
    }
    
    public int getLeftLightSensor() {return leftDistSensor.getValue();}
    
    public int getRightLightSensor() {return rightDistSensor.getValue();}
    
    public int getLeftEncoder() {return leftEncoder.get();}
    
    public int getRightEncoder() {return rightEncoder.get();}
    
    
}

